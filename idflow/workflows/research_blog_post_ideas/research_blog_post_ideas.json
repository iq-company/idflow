{
  "name": "research_blog_post_ideas",
  "version": 3,
  "schemaVersion": 2,
  "inputParameters": [
    "docId",
    "research_methods"
  ],
  "tasks": [
    {
      "name": "read_document_content",
      "taskReferenceName": "read_doc",
      "type": "INLINE",
      "inputParameters": {
        "evaluatorType": "javascript",
        "docId": "${workflow.input.docId}",
        "expression": "(function(){\n  // This would normally read from the document store\n  // For now, we'll simulate reading the document\n  return {\n    content: 'MLLM vs. OCR - A comprehensive comparison of Machine Learning Language Models versus Optical Character Recognition technologies',\n    tags: ['blog_post_ideas'],\n    id: $.docId\n  };\n})()"
      }
    },
    {
      "name": "extract_research_topics",
      "taskReferenceName": "extract_topics",
      "type": "INLINE",
      "inputParameters": {
        "evaluatorType": "javascript",
        "content": "${read_doc.output.result.content}",
        "expression": "(function(){\n  // Extract key topics from the content for research\n  var content = $.content;\n  var topics = [];\n  \n  // Ensure content is a string\n  if (typeof content !== 'string') {\n    content = 'MLLM vs. OCR - A comprehensive comparison of Machine Learning Language Models versus Optical Character Recognition technologies';\n  }\n  \n  // Simple keyword extraction (in real implementation, use NLP)\n  var keywords = ['MLLM', 'OCR', 'Machine Learning', 'Language Models', 'Optical Character Recognition', 'comparison', 'technologies'];\n  \n  // Process keywords safely\n  try {\n    keywords.forEach(function(keyword) {\n      if (content && typeof content === 'string' && content.toLowerCase().includes(keyword.toLowerCase())) {\n        topics.push(keyword);\n      }\n    });\n  } catch (e) {\n    // Fallback if there are any issues\n    topics = ['MLLM', 'OCR', 'Machine Learning'];\n  }\n  \n  return {\n    topics: topics,\n    research_query: 'MLLM vs OCR comparison machine learning language models optical character recognition'\n  };\n})()"
      }
    },
    {
      "name": "parallel_research",
      "taskReferenceName": "parallel_research",
      "type": "FORK_JOIN",
      "forkTasks": [
        [
          {
            "name": "gpt_researcher_task",
            "taskReferenceName": "gpt_research",
            "type": "SIMPLE",
            "inputParameters": {
              "query": "${extract_topics.output.result.research_query}",
              "docId": "${workflow.input.docId}"
            }
          }
        ]
      ]
    },
    {
      "name": "join_research_results",
      "taskReferenceName": "join_research",
      "type": "JOIN",
      "joinOn": ["gpt_research"]
    },
    {
      "name": "consolidate_research_results",
      "taskReferenceName": "consolidate",
      "type": "INLINE",
      "inputParameters": {
        "evaluatorType": "javascript",
        "gpt_results": "${gpt_research.output}",
        "docId": "${workflow.input.docId}",
        "expression": "(function(){\n  // Consolidate results from GPT research\n  var gptData = $.gpt_results || {};\n  \n  // Create consolidated result with doc attribute for stage workflow compatibility\n  var consolidated = {\n    docId: $.docId,\n    research_methods: ['gpt_researcher'],\n    results: {\n      gpt_researcher: gptData\n    },\n    summary: 'Research completed using GPT Researcher method',\n    timestamp: new Date().toISOString(),\n    doc: {\n      content: 'Research completed for: ' + (gptData.query || 'unknown query') + '\\n\\n' + (gptData.summary || 'No summary available'),\n      title: 'Research Results: ' + (gptData.query || 'Unknown Query'),\n      type: 'research_results',\n      created_at: new Date().toISOString()\n    }\n  };\n  \n  return consolidated;\n})()"
      }
    },
    {
      "name": "save_research_results",
      "taskReferenceName": "save_results",
      "type": "INLINE",
      "inputParameters": {
        "evaluatorType": "javascript",
        "results": "${consolidate.output.result}",
        "expression": "(function(){\n  // Return the consolidated results with doc attribute\n  var consolidated = $.results || {};\n  \n  return {\n    success: true,\n    message: 'Research results processed successfully',\n    results: consolidated,\n    doc: consolidated.doc || null\n  };\n})()"
      }
    }
  ],
  "outputParameters": {
    "researchResults": "${save_results.output.result.results}",
    "success": "${save_results.output.result.success}",
    "doc": "${save_results.output.result.doc}"
  },
  "ownerEmail": "idflow@example.com"
}
